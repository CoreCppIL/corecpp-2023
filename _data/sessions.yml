#-
#  id: 012
#  title: "Linux Security and Isolation APIs essentials"
#  description: >
#    <p><b>WORKSHOP</b></p>
#    <p>This course provides an overview of the low-level Linux features–set-UID programs, capabilities, namespaces, and control groups (v2)–that are used
#    to implement privileged applications and build container, virtualization, and sandboxing technologies. (The course does not cover systems such as
#    Docker and LXC, but participants will gain an an insight into the implementation and operation of such systems.)</p>
#    <p>The primary audience comprises designers and programmers building privileged applications, container applications, and sandboxing applications.
#    Systems administrators who manage such applications will also find the course of benefit. Participants should have some awareness of classical
#    Linux/UNIX concepts such as file descriptors and file I/O, signals, and the process lifecycle (fork(), exec(), wait(), exit()). In addition,
#    participants should have a reading knowledge of the C programming language. (Note, however, that the course exercises do not require writing any programs.)</p>
#    <p>Limited seats, <a href="https://ti.to/hamakor/core-cpp-2022/with/6t7udu7msda">register now</a>!</p>
#  subtype: workshop
#  speakers: [21]
#  language: en
-
  id: 002
  title: "Closing session"
  description: "TBD"
-
  id: 005
  title: "A lot of great C++ content!"
  description: "A lot of great C++ content! Sumbit yours at <a href='https://cfs.corecpp.org/'>https://cfs.corecpp.org/<a>"
-
  id: 006
  title: "More activities"
  description: "In construction"
  service: true
-
  id: 007
  title: "Meetup & Lightning Talks"
  description: "Stay tuned!"
  service: true
-
  id: 008
  title: "Great C++ content!"
  description: "To be published soon"
  service: true
-
  id: 099
  title: "Welcome to Core C++ 2023!"
  #place: "Weston::Auditorium"
  subtype: keynote
  service: true
-
  id: 1000
  title: ""
  service: true
-
  id: 101
  title: "Break"
  service: true
-
  id: 102
  title: "Lunch"
#  place: "Economics::Lobby"
  service: true
-
  id: 104
  title: "Updates"
  #place: "Weston::Auditorium"
  service: true
-
  id: 105
  title: "Closing Remarks"
  #place: "Weston::Auditorium"
  service: true
-
  id: 106
  title: "Registration and Coffee"
#  place: "Economics::Lobby"
  service: true
-
  id: 107
  title: "Coffee Break"
#  place: "Economics::Lobby"
  service: true
#  speakers: [30, 31]
-
  id: 1001
  title: "Day Trip"
  description: >
    <p>We're excited to invite you to participate in our planned trip for CoreC++ abroad guests!</p>
    <p>The tour will be to the Dead Sea area and Jerusalem.</p>
    <p>The fee includes a private tour guide, travel, and lunch.</p>
    <p>The tour is planned to leave from the Margoza hotel in Tel Aviv in the morning of September 4th, ~8:00 AM. The return time planned is ~18:00.</p>
    <p>The tour is open for your travel companions.</p>
  service: true
-
  id: 10
  title: "Keynote"
  subtype: keynote
  speakers: [10]
-
  id: 15
  title: "Keynote"
  subtype: keynote
  speakers: [15]
-
  id: 11
  title: "Designing and Implementing Safe C++ Applications"
  description: >
    <p>This workshop aims to address the design and implementation principles and tactics necessary for creating secure C++
    applications. While memory issues will be given proper attention, it's important to note that application safety extends
    beyond this. To ensure application safety, it is crucial to capture requirements correctly, make appropriate design choices,
    implement code securely, and conduct testing, static code analysis, and dynamic sanitizing. Through relevant
    examples and class practice, we will cover the entire life cycle of creating secure applications, and provide a
    checklist for achieving enhanced safety and improved code quality.</p>
  speakers: [11]
-
  id: 12
  title: "Concurrency in Modern C++"
  description: >
    <p>This class gives you a detailed insight into the multithreading facilities of C++. Starting with the foundation
    in C++11, continuing with the parallel STL in C++17, and closing with the concurrency features in C++20.</p>
  speakers: [12]
-
  id: 13
  title: "Exploring Rust to Enhance Your C++ Skills"
  description: >
    <p>This class is designed to help C++ developers explore Rust, an increasingly popular and powerful language. Through
    hands-on examples and projects, students will learn why Rust has become so widely adopted and why it is such an attractive
    choice for C++ developers. Learning Rust will not only enable attendees to take a peek at this new language, but
    will also greatly enhance the quality of their C++ code.</p>
    <p>In the first part of the class, students will learn about Rust's history, governance model, and community. We will
    also discuss the main technical selling points of Rust and its current level of maturity. Following this, we will go through a
    "Hello World" example in Rust so that students can become familiar with Rust's syntax and understand some of the fundamental features.</p>
    <p>To further solidify their understanding of these concepts, students will then work on a "guess the number" game project.
    We will look at how to improve the game by using pattern matching and extracting functionality to separate functions.</p>
    <p>In addition to the fundamentals, the class will cover the use of external libraries. We will discuss what a "crate" is
    and how to find and add one via cargo. We will also look at intermediate features like structs and enums, dynamic allocation,
    traits and polymorphism, strings and manipulation, and common standard library containers and utilities.</p>
    <p>Two additional projects will also be included. Students will re-create the Wordle game in Rust and add a CLI to the "guess
    the number" game, using the 'clap' 3rd party crate. Finally, we will showcase other compelling Rust features such as lifetimes,
    async, compile-time thread safety, compile-time evaluation, hygienic macros, and interoperability with C++.</p>
    <p>By the end of the class, attendees will have acquired the knowledge and skillset necessary to start their journey with Rust,
    and they will be able to apply the learned notions to their C++ development mindset.</p>
  speakers: [13]
-
  id: 14
  title: "Linux System Programming Essentials"
  description: >
    <p>This workshop provides an introduction to the low-level interfaces that are used to build system-level applications on
    Linux (and UNIX) systems. Topics covered include file I/O using system calls, signals, processes, and process lifecycle
    (<code>fork()</code>, <code>execve()</code>, <code>wait()</code>, <code>exit()</code>).</p>
    <p>There will be practical programming sessions as part of the workshop.</p>
  speakers: [14]
#-
#  id: 20
#  title: "C++"
#  description: >
#    <p></p>
#  speakers: [20]
-
  id: 21
  title: "Better Code: Exploring Validity"
  description: >
    <p>Most developers have at least some notion of the meaning of object, state, invariant, value, and invalid. On the other hand,
    it can be surprisingly difficult to precisely define these words in a way that matches both intuition and common usage. This difficulty
    has even led to library divergence within the C++ standard library!</p>
    <p>This talk is a journey of discovery where we not only find satisfactory definitions, but we identify practical, good coding practices
    along the way. At the end of this talk you'll be able to identify implicit contracts, understand the deep connection between move semantics
    and exception safety, and, in general, have a greater appreciation for the meaning of the programs we write every day.</p>
  speakers: [21]
-
  id: 22
  title: "Lightning Updates"
  description: >
    <p>This talks describes an update system designed for scale of 100s M of users. It presents generic solution to update any data-structure in a simple way using modern C++ facilities in standard library only. It shows arguments for strong types and readable code using verbs and nouns. Even if you are not going to need such functionality, this talk can serve as an inspiration how to write clean code.</p>
  speakers: [22]
-
  id: 1011
  title: "C++ Incidental Explorations"
  description: >
    <p>Let's embark on a journey through the exciting discussions about C++, found in StackOverflow's Q&A. We will cover both fundamental issues as well as anecdotal corners of the language, get lost down a few rabbit holes, and become familiar with some topics usually reserved for "language lawyers". We will finish by exploring whether, and how ChatGPT might help with writing C++ in the future.</p>
  speakers: [11]
-
  id: 23
  title: "The Imperatives Must Go!"
  description: >
    <p>Can a language whose official motto is "Avoid Success at All Costs" teach us new tricks in modern C++ ? If Haskell is so great, why hasn't it taken over the world? My claim is that it has. But not as a Roman legion loudly marching in a new territory, rather as distributed Trojan horses popping in at the gates, masquerading as modern features or novel ideas in today’s mainstream languages. Functional Programming ideas that have been around for over 40 years will be rediscovered to solve our current software complexity problems. Indeed, modern C++ has become more functional. From mundane concepts like lambdas & closures, std::function, values types and constants, to composability of STL algorithms, lazy ranges, folding, mapping or even higher-order functions in STL. Did I mention Rust yet? In this session we’ll analyze a bunch of FP techniques in C++ and see how they help make our code shorter, clearer and faster, by embracing a declarative vs. an imperative style.
    We’ll visit the functional parts of current STL, use algebraic data types (ADT) and learn about the new FP stuff coming in the next C++ standard, like ranges or monadic extensions to <code>std::future</code>, <code>std::optional</code> and <code>std::expected</code>. Brace yourselves for a bumpy ride including composition, lifting, currying, partial application, pure functions, maybe even pattern matching and lazy evaluation.</p>
  speakers: [23]
-
  id: 24
  title: "Multi-Paradigm Programming and Beyond"
  description: >
    <p>Most everybody has heard that C++ is a Multi-Paradigm Programming Language, but what does that really mean?</p>
    <p>The defined language paradigms are: Imperative, Procedural, Functional, Declarative, & Object-Oriented, but what does that really mean?</p>
    <p>These are the building blocks in the levels of granularity, almost a base implementation style but when many people say paradigm when they are really thinking of bigger more sophisticated conceptual processing and data models.</p>
    <p>What are some of these alternate paradigms people are thinking of. Join us for an exploration of what paradigms are, what they look like, and how do they are used in software design.</p>
  speakers: [24]
-
  id: 25
  title: "Standard C++ toolset"
  description: >
    <p>Programming languages nowadays are often packed with a standard set of tools that form an ecosystem around it. Compilers and debuggers, static analyzers, build systems, dependency managers, and unit testing frameworks are essential for adoption and evolve with the language.</p>
    <p>C++ is about to turn 40. Though the ecosystem was very diverse and incomplete for many years, it is getting better! In this talk, I will discuss:</p>
    <p><ul>
        <li>The typical “project model - compiler - debugger” triad, and how it still depends on the area of usage (Embedded or Game Development).</li>
        <li>How the build systems and dependency managers are now more standard.</li>
        <li>How Clang affected the standard toolset in all areas, forming not only a baseline for compilers, but also formatters, code analyzers, and IDEs.</li>
        <li>How many code analyzers exist for C++ and why there is still room for improvement.</li>
        <li>How unit testing and code coverage solutions can be used effectively.</li>
        <li>And finally, how the language committee is learning to listen to and help standard toolset contributors.</li>
    </ul></p>
    <p>You’ll get a better understanding of the tools available to help you develop complex solutions in C++ without struggling with toolsets.</p>
  speakers: [25]
-
  id: 16
  title: "Let's talk about C++'s Abstraction Layers"
  description: >
    <p>Abstraction Layers are one of the strongest tools we're using for software development. Even though being taught during the first semester of a Computer Science undergraduate and is widely used throughout the everyday workflow of software development, a lot of logic bugs occur by wrong usage of this concept.</p>
    <p>During this talk, we will define and explore the C++ abstractions layers, through both the mental model as reflected in papers, as well as through past mistakes and bugs. We will introduce some ground rules to encourage more correct usage of this concept, by extrapolating from examples from the latest C++23 and C++26 standards' features. Finally, we will review a proposal for addressing ISO C++ WG21 committee work.</p>
    <p>This is an exploratory talk, audience participation is highly encouraged!</p>
  speakers: [16]
-
  id: 1012
  title: "Concurrency Improvements in C++20: A Deep Dive"
  description: >
    <p>With the publishing of the C++11 standard, C++ got a multithreading library and a memory model. This library has basic building blocks like atomic variables, threads, locks, and condition variables. That’s the foundation on which C++ standards such as C++20 can establish higher-level abstractions consisting of extended atomics, semaphores, latches and barriers, cooperative interruption, an improved std::jthread, and synchronized output streams.</p>
  speakers: [12]
-
  id: 26
  title: "Instruction Level Parallelism in Your C++ Program"
  description: >
    <p>Instruction Level Parallelism (ILP) is the magic ingredient of a modern CPU that makes it run fast. But not all programs are equal, some have more ILP, others have less. In this talk we are going to divide our hot loops into two types : low-ILP and high-ILP, and then we will focus our attention on how to make those low-ILP loops faster.</p>
  speakers: [26]
-
  id: 27
  title: "Running Away From Computation - An Introduction"
  description: >
    <p>One of the fun and motivating reasons to use the C++ programming language is the ability to optimize code. One of the best ways to optimize code is to avoid any computation in the first place! In this talk, we are going to learn how to approach the C++ programming language, thinking about compile-time computation (e.g. constexpr, static_assert, and template meta-programming) and some other tricks to avoid computation at run-time (e.g. short-circuit evaluation, caching, and lazy evaluation). In this talk, participants will learn how these techniques improve performance (with measurements using the perf profiler), as well as learn how these techniques also make C++ a safer programming language. This talk is targeted towards beginner to intermediate range C++ programmers.</p>
  speakers: [27]
-
  id: 28
  title: "Being RESTful with billions of dollars in transactions, thanks to C++, JSON and HTTP"
  description: >
    <p>In this talk I provide my experience on the last three years of building restful interfaces in C++ using nlohmann::json and cpp-httplib. I will present a case study showing you the basics of how each of these header only libraries work, teasing out the pros and cons for our companies needs. Some insights into how Restful APIs like Stripe are created will be provided, and we’ll look at how using, and converting to strong types using proper design patterns can make your life easier if you go down the same route. Throughout the talk, I’ll specifically share in the experience gained from implementing RESTful APIs in credit card transaction systems with Mastercard/Visa. Join this session to learn how you can use JSON and/or HTTP to interface with almost anything.</p>
  speakers: [28]
-
  id: 1014
  title: "Understanding Linux user namespaces"
  description: >
    <p>User namespaces are at the heart of many interesting Linux technologies that allow isolation and sandboxing of applications, for example running containers without root privileges and sandboxes for web browser plug-ins. In this presentation, we’ll look in detail at user namespaces, building up a basic understanding of what a user namespace is and going on to questions such as: what does being "superuser inside a user namespace" allow you to do (and what does it not allow); and what is the relationship between user namespaces and other namespace types (PID, UTS, network, etc.)? We’ll also employ some simple shell commands to create and experiment with user namespaces in order to better understand how they work.</p>
  speakers: [14]
-
  id: 00
  title: "C++"
  description: >
    <p></p>
  speakers: [00]
-
  id: 29
  title: "From a modern to an unbelievably modern C++"
  description: >
    <p>"Why should we move to a more advanced C++ version if we can already archive everything with C++11, which is also considered as a modern C++?"</p>
    <p>"If you ask yourself this question, this talk is for you. In this talk we'll discuss the new features from C++17 to C++20, and we'll talk briefly about major features in 23.</p>
    <p>"C++11/14 brought us the beginning of useful features like lambda expressions, iterators improvements, constexpr, auto and more. However, the more the C++ standard made progress, the more compile time options have been added and the readability became easier to archive. Moving forward gives more stability to code, based on the most experienced C++ developers' experience, who take part as standard and compilers writers.</p>
  speakers: [29]
-
  id: 30
  title: "Development Strategies - The stuff around the code"
  description: >
    <p>We all like to write code - right? But to write a successful piece of software requires effort on aspects other than the code.</p>
    <p>In this talk, I will list some of these topics, and suggest techniques that will help you be successful. Things like testing, documentation, dealing with user questions and bug reports, along with tools to help you make your code better. I'll talk about static analysis, sanitizers, fuzzing,</p>
    <p>The talk will feature examples from libc++, Boost, and other projects.</p>
  speakers: [30]
-
  id: 1013
  title: "Improving Compilation Times: Tools & Techniques"
  description: >
    <p>"Modules will solve everything", people say -- some optimistically, others sarcastically. However, modules are far from reaching real-world maturity, and it is still not certain whether they will improve compilation times in every situation and how costly it will be to migrate a large codebase.</p>
    <p>Do we have to suffer with excruciating compilation times until we are able to migrate to modules? Not at all!</p>
    <p>If you are interested in learning about practical tools and techniques to improve compilation times on codebases of any size, today, this talk is for you! We will cover:</p>
    <p><ul>
        <li>How to accurately benchmark the compilation time of a codebase and detect bottlenecks;</li>
        <li>Enabling precompiled headers in CMake, leveraging the "reuse from" feature;</li>
        <li>Automatically transforming your build into a "unity build";</li>
        <li>When to selectively replace heavyweight standard library headers;</li>
        <li>General techniques to reduce physical dependencies between components.</li>
    </ul></p>
  speakers: [13]
-
  id: 31
  title: "MDSPAN: A Deep Dive Spanning C++, Kokkos & SYCL"
  description: >
    <p>This talk is a deep dive into the history behind MDSPAN (it’s roots being in Kokkos::View), the C++ standardization effort behind it (current status, various tradeoffs made over time, and language changes to help support it) and how SYCL is looking to leverage it in the future. MDSPAN is a non-owning multidimensional array reference, currently slated to be one of the flagship libraries added to C++23. View/reference vocabulary types first entered C++17 with string_view (a non-owning string reference), followed by span (a non-owning single dimension contiguous memory reference) and the ranges library. MDSPAN is the natural progression of this, and one that is critical to distributed (eg. CPU/GPU programming) and high-performance computing.</p>
    <p>MDSPAN got its roots from Kokkos::View, One key difference between Kokkos::View & MDSPAN: Kokkos::View may be owning (reference-counted reference semantics) or non-owning. The former is also being standardized for C++26 as MDARRAY, although with value and not reference-counted semantics. Separately, in 2014 Microsoft proposed a similar type, array_view, be added to the standard. After a year and a half and seven revisions, it was ultimately abandoned in favor of what is now MDSPAN because it did not provide a zero-overhead abstraction.</p>
    <p>The MDSPAN proposal itself has taken seven years and has been through 17 revisions, with input from many different companies as well as the C++ Committee. What changed over the years and why did it change? In parallel, two key language changes were made which ultimately improved the interface: deprecating the comma operator inside square brackets, and the addition of the multidimensional subscript operator. This allows the natural syntax of a[I, j, k] instead of inferior alternatives like a(i, j, k), a[I][j][k] or even a[Index(i), j, k].</p>
  speakers: [31]
-
  id: 32
  title: "C++23 ranges: conceptual changes and useful practicalities"
  description: >
    <p>Being introduced to C++20, ranges changed the way we write code. C++23 not only brings with it a large pile of new utilities but actually introduces a fundamental change to one of the core concepts in the ranges world - the view.</p>
    <p>Absurd as it sounds, views can now also own their elements while still being cheap to pass around. This talk will explain how that works as well as describe the most useful algorithms and adaptors we can now take advantage of, like using std::generator to implement range adaptors, printing ranges, or even using the new std::optional monadic interface.</p>
  speakers: [32]
-
  id: 33
  title: "More Ranges Please"
  description: >
    <p>Ranges are one of the major additions of C++20, in which our main abstraction for sequences shifted from iterator-pairs into full fledged concepts, allowing better composability, expressibility and safety when working with bounded and even unbounded one dimensional sequences of data. The fluent use of the pipe-operator gave us power to write complex functional-style algorithms which are both highly readable and perfomant. The ranges library, especially with some recent C++23 additions also better exposes us to the notion of 'range-of-ranges' and multi-dimentional spans, which weren't in focus of the STL in prior versions of the language.</p>
    <p>One key feature of the STL since the last century was the large number of algorithms and building blocks which seemed woven together and gave us a vocabulary by which algorithms could be expressed with little need to work with raw loops.</p>
    <p>Together with the introduction of ranges, the STL has also gained various range-based algorithms (mostly views and adapters), yet most of those algorithms basic adaptations of the ones that are available in the iterator-pair model.</p>
    <p>In a talk from 2002, the primary designer of STL <a href="https://youtu.be/YlVUzJwN_Xc?t=660">described the process of gathering, currating and solidifying</a> the algorithms in the STL circa 1998. This talk aims to apply a similar process to the universe of C++20/C++23 ranges, and propose potential additions to our vocabulary when developing range-based algorithms.</p>
    <p>We will go over a variety of algorithms which currently don't exist for ranges, describe their potential value, and discuss whether they can or should be added to the standard.</p>
    <p>A few examples of algorithms which will be covered:</p>
    <p><ul>
        <li>Algorithms for sorted ranges, such as <code>take_between</code> and <code>histogram</code>, ...</li>
        <li>Algorithm for ranges-of-(sorted-)ranges, such as <code>merge_join</code>, <code>set_union</code>, <code>set_intersection</code>, ...</li>
        <li>Algorithms which might require some helper data structures, such as <code>histogram</code> (for non sorted ranges)</li>
        <li>Algorithms tailored for multi-dimensional ranges (or mdspan), such as <code>sort_dimension</code></li>
    </ul></p>
    <p>As we go through the various examples, we'll discuss what might be good candidates for addition to the STL (and reference prior talks on the topic), the notion of sorted ranges, and hopefully leave the talk with a good desire to compose algorithms in the brave new world of ranges</p>
  speakers: [33]
-
  id: 34
  title: "Lazy and Proud: How I Failed to Standardize lazy_counted_iterator"
  description: >
    <p>Have you ever wondered what it takes to write a proposal for the C++ standard? Have you had an idea on how to improve this language or its standard library and decided it was worth standardizing? Well, I did. And I failed. But I'm happy that I failed. Even happier than if I'd succeeded!</p>
    <p>In this talk, I will share my experience of proposing P2406, where we demonstrated a design flaw of counted_iterator and suggested a fix, and why it wasn't accepted into the standard.</p>
    <p>We'll briefly discuss C++20 ranges as background material, but the audience is expected to understand the basics of STL (the use of iterators to communicate between containers and algorithms).</p>
  speakers: [34]
-
  id: 35
  title: "C++ for the cloud"
  description: >
    <p>The cloud is revolutionizing scalable and distributed computing but is difficult to take advantage of in C++. While cloud functions can scale up to unlimited concurrency, calling them takes dozens of lines of complex C++ code. While NoSQL databases are ubiquitous associative containers, they cannot be used in a range, and so forth.</p>
    <p>What if we could make cloud functions as easy to use as thread functions, NoSQL databases as easy to use as any other associative container, and do the same for other cloud services as well? You don't just have to imagine it. In this talk, I will show how you can take advantage of the cloud with simple and natural C++.</p>
  speakers: [35]
-
  id: 36
  title: "Performance-related coding guidelines"
  description: >
    <p>Performance as the top priority is the defining aspect of C++. No other programming language provides the performance-critical facilities of the language. This talk is about performance-related coding guidelines in modern C++. We will discuss generic issues everyone can use daily to make code performant but still readable. Several examples will be analyzed in detail to understand better how they are implemented. We won’t dive into low-level optimizations. We will discuss the more effective use of data structures, algorithms, constexpr, etc. Each suggestion is supported by benchmarks and some explanations that can help with better intuition.</p>
  speakers: [36]
-
  id: 37
  title: "Expressive Compile Time Parsers"
  description: >
    <p>Modern C++ has many language features and that can be leveraged to design an expressive API or a domain-specific language. However, these features are limited by the syntax rules of C++. To overcome this limitation, we will discuss the use of compile-time parsers to write more expressive code with zero overhead.</p>
    <p>We will analyze open-source compile-time parsing libraries from C++11 to C++23 and compare their APIs in terms of flexibility and expressiveness. Additionally, we will delve into the techniques used in the implementation of these libraries to handle compile-time parsing under the constraints of compile-time execution.</p>
    <p>Finally, we will highlight how these libraries can be used to reduce boilerplate and write compile-time regular expressions, parsers, parser generators, Rust's macro rules and reflection features. Attendees of this talk will gain a deeper understanding of the power and versatility of compile-time parsers in C++.</p>
  speakers: [37]
-
  id: 39
  title: "To Int or to Uint, This is the Question"
  description: >
    <p>In our daily work, we often use integral data types to perform arithmetic calculations, but we may not always consider how the selection of the data type can affect performance and compiler optimizations. This talk will delve into the importance of choosing the correct data type for the job and how it impacts compiler optimizations. We will also examine the overall performance implications for the application. We will explore specific algorithms where using unsigned data types is more beneficial and other situations where signed data types are the best choice. Attendees will come away with a deeper understanding of how data type selection can impact their code and how to make better choices for optimal performance.</p>
  speakers: [39]
-
  id: 40
  title: "Compile time polymorphism: the optimization that (sometimes) isn't"
  description: >
    <p><b>Oh no! This code has virtual functions!! Quick!!!! We need to rewrite it as templates!!!!!</b></p>
    <p>For some time, inheritance has been getting a bad rap. In this lecture we'll dive into why that is, what alternatives there are, and are they actually better.</p>
    <p>We'll also touch on the subject of caches and the limitations of sample profiling as means for determining which is faster.</p>
  speakers: [40]
-
  id: 41
  title: "Easy to use, hard to misuse: Practical guidelines to tame your API"
  description: >
    <p>The second most quoted statement in program development is “make your API easy to use correctly, hard to use incorrectly”. But what does this really mean? Most examples that explain this are very basic and deal more with readability of the code than with actual protection against misuse or incorrect usage.</p>
    <p>We want our API's to be simple and generic. We want to allow for a wide variety of operations to be done simply. But we also want it to be used correctly and to protect against mistakes. Unfortunately, as we will see in this talk, these two goals can conflict with each other.</p>
    <p>In this talk I will demonstrate some design and implementation decisions I encountered in real life code. We will discuss different considerations we need to take into account when designing our API and see how we can make the code guide you towards using it correctly.</p>
  speakers: [41]
-
  id: 42
  title: "Scope Sensitive Programming"
  description: >
    <p>Classically, functions and methods use arguments in order to produce a variety of results. But at times, this means passing “configuration” arguments to many APIs, which may hit hard maintainability and readability. Alternately, classes introduce configuration APIs in order to affect their general behavior. But these require special care when shared objects are invoked from multiple threads.</p>
    <p>In this talk a novel but simple approach is presented, which affects the behavior of code, depending on the calling context. It eliminates the need to refactor big APIs with configuration arguments, and it is completely thread safe. Most of all, it lends itself to a flow-centric approach, where desired behaviors map naturally to code scopes.</p>
    <p>A few use cases will be presented, such as logging, decorators, event counting, dependency injection, and caching.</p>
  speakers: [42]
-
  id: 43
  title: "Lessons I learn from improving legacy product and doubling its performance"
  description: >
    <p>On 2017, I worked on an embedded central unit (linux, c++, QT) that was supposed to listens to many endpoints and pass their rf frames to the Server. Sometimes we had unexplained resets and sometimes we lost data(frames). I emphasize sometimes because most of the time everything worked well. This made it harder to find and simulate the problems. The central unit was supposed to support 7500 endpoints but in the real world after 5000 endpoints it crashed occasionally. Customers complained, the software was hard to maintain and very unpopular (for the developers) to work on. After two years of work, the unit supported 10k endpoints without resets or any loss of data. Let me tell you, how we did it.</p>
  speakers: [43]
-
  id: 44
  title: "The Concept of Templates"
  description: >
    <p>Template programming became a fundamental feature in C++, presenting many basic and advanced features that are necessary for writing a faster, effective and more flexible program.</p>
    <p>In my presentation, I will cover some basic and advanced features that are necessary for C++ programmers, including the basics, the process of compiling such programs and what this process (instantiation) has to do with the concept of specializing a template.</p>
    <p>In addition - I will talk about the meaning of writing understandable and convenient template code, how to achieve it by using C++20 features, and will teach the basics of meta-programming and static computations - in terms of template C++ programming.</p>
  speakers: [44]
-
  id: 45
  title: "Virtual templated methods"
  description: >
    <p>You can write a virtual method, you can write a templated method, but you can't write a method which is both. In this talk we will discuss why that is, why you might still want it, and give a few suggestions as to what to do about it.</p>
  speakers: [45]
-
  id: 46
  title: "Building low latency, network intense applications with C++"
  description: >
    <p></p>
  speakers: [46]
-
  id: 47
  title: "Nobody Can Program Correctly. A Practical and Interactive Guide to Debugging C++ Code"
  description: >
    <p>We like to write code but—despite our best efforts—we make mistakes. Our program will contain bugs. Sometimes, we don’t write what we mean to write, sometimes we don’t understand an aspect of our programming language and at other times we lack—or fail to consider—some critical information about our program’s system environment. As a result, our program will not behave correctly. What do we do now?</p>
    <p>In this talk, I would like to take you through the entire debugging process, starting with a program that crashes. What do we do next? Which questions do we have to ask? What information do we need? What can we do to find the cause of the crash? Which tools can help us in this quest, and, last but not least, what can we do to make sure this bug never happens again? Thanks to real-world examples that we have encountered—and debugged—at think-cell over the years, you will learn how to reproduce, locate, understand and fix even the most difficult bugs.</p>
  speakers: [47]
-
  id: 48
  title: "Accelerated C++ with OpenMP"
  description: >
    <p>In recent years, co-processors and accelerators such as GPUs have become increasingly prevalent in high-performance computing. These devices are designed to handle a massive amount of parallelism and have much higher computing power than traditional CPUs. OpenMP, an application programming interface (API) for shared-memory parallel programming, has adapted to this changing hardware landscape by adding directives that can map codes and data onto these devices. These directives are known as target directives, and they allow for efficient programming of GPUs and other specialized accelerators. Target directives can significantly improve the performance of high-performance code (such as Fortran, C, and C++) running on heterogeneous systems. They allow for the distribution of work across multiple devices, enabling the programmer to take full advantage of the processing power available on each device. This can result in significant speedups, especially for code that requires a high level of parallelism. In this talk, we will delve into the specifics of using target directives for programming GPUs. We will examine the advantages of target directives over classic shared-memory parallelism and explore how they can be used to optimize code for maximum performance. We will also discuss some of the challenges and trade-offs involved in using target directives, including issues related to memory management and data transfers between devices.</p>
  speakers: [48]
-
  id: 49
  title: "UB effects on real world projects"
  description: >
    <p>Undefined behavior and its liberal adoption by compilers is pretty unique to C/C++. Number of so-called UBs and their implication is an order of magnitude larger compared to similar languages, e.g., Ada, and is the source of hard to find bugs as well as security vulnerabilities.</p>
    <p>Scott Meirs popularized the notion of UB summoning "nasal demons", yet most of the noses of veteran C++ programmers are intact.</p>
    <p>To understand and mitigate UB in large code bases, it is crucial to understand how the UB can affect your code.</p>
    <p>We will survey real life bugs and security vulnerabilities, and how exactly they affect the code.</p>
    <p>We will show several categories of misbehavior that could be caused by UB, and will try to bound the implication of it.</p>
  speakers: [49]
#-
#  id: 00
#  title: "C++"
#  description: >
#    <p></p>
#  speakers: [00]
